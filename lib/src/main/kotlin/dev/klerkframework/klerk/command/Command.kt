package dev.klerkframework.klerk.command

import dev.klerkframework.klerk.*
import dev.klerkframework.klerk.defaultDebugOptions
import io.ktor.util.*
import org.slf4j.event.Level
import kotlinx.datetime.Instant
import kotlinx.datetime.Clock

/**
 * A class describing an event.
 *
 * @param model the model (if any) on which this event should apply
 */
public data class Command<T : Any, P>(
    public val event: Event<T, P>,
    public val model: ModelID<T>?,
    public val params: P,
)

/**
 * @param token used to ensure idempotency (the token can only be used once) and may also ensure that the command is
 * only accepted if the model has not been changed by someone else. The token may be generated by the client.
 * @param dryRun if true, the command is processed and all rules are evaluated, but the event will not have any effect.
 */
public data class ProcessingOptions(
    public val token: CommandToken,
    public val dryRun: Boolean = false,
    public val debugOptions: Map<DebugOptions, Level> = defaultDebugOptions
)

public enum class DebugOptions {
    sequence,
    misc,
    result
}

public data class CommandToken(
    internal val time: Instant = Clock.System.now(),
    internal val models: Set<ModelID<out Any>> = emptySet(),
) {

    public companion object {
        public fun simple(): CommandToken = CommandToken()

        public fun requireUnmodifiedModel(id: ModelID<out Any>): CommandToken = CommandToken(models = setOf(id))

        public fun requireUnmodifiedModels(ids: Set<ModelID<out Any>>): CommandToken = CommandToken(models = ids)

        public fun from(string: String): CommandToken {
            var time: Instant? = null
            var models: Set<ModelID<Any>>? = null
            string.decodeBase64String()
                .split(":")
                .forEach { keyValueString ->
                    val keyValueList = keyValueString.split("=")
                    require(keyValueList.size == 2)
                    val key = keyValueList.first()
                    val value = keyValueList.last()
                    if (key == "t") {
                        time = decode64bitMicroseconds(value.toLong())
                    }
                    if (key == "m") {
                        models = if (value.isEmpty()) emptySet() else
                            value.split(",").map { ModelID.from<Any>(it) }.toSet()
                    }
                }
            return CommandToken(time = requireNotNull(time), models = requireNotNull(models))
        }
    }

    override fun toString(): String {
        return "t=${time.to64bitMicroseconds()}:m=${models.joinToString(",")}".encodeBase64()
    }
}
